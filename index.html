<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clothing Store Showcase</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
    }

    #info-card {
      position: fixed;
      top: 42%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 30px 40px;
      min-width: 400px;
      max-width: 500px;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s ease;
      font-family: 'Work Sans', sans-serif;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }

    #info-card.visible {
      opacity: 1;
    }

    #info-card.left {
      left: 40px;
    }

    #info-card.right {
      right: 40px;
    }

    #info-card h2 {
      font-size: 32px;
      font-weight: 700;
      margin: 0 0 15px 0;
      color: #ffffff;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    #info-card .label {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.6);
      margin: 0 0 8px 0;
    }

    #info-card .inspiration {
      font-size: 16px;
      font-weight: 400;
      line-height: 1.6;
      margin: 0 0 20px 0;
      color: rgba(255, 255, 255, 0.95);
    }

    #info-card .role {
      font-size: 15px;
      font-weight: 500;
      margin: 0;
      color: rgba(255, 255, 255, 0.85);
    }

    #info-card .buttons {
      display: none;
      gap: 12px;
      margin-top: 20px;
    }

    #info-card.with-buttons .buttons {
      display: flex;
    }

    #info-card.with-buttons {
      pointer-events: auto;
    }

    #info-card button {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      padding: 10px 20px;
      color: white;
      font-family: 'Work Sans', sans-serif;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #info-card button:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
    }

    #controls-menu {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 16px 32px;
      color: white;
      font-family: 'Work Sans', sans-serif;
      display: flex;
      gap: 24px;
      align-items: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transition: opacity 0.3s ease;
      z-index: 1000;
    }

    #controls-menu.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .control-label {
      font-size: 14px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
    }

    .keys {
      display: flex;
      gap: 6px;
    }

    .key {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 600;
      color: white;
      min-width: 32px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.1s ease;
    }

    .key.active {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.3));
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 4px 16px rgba(255, 255, 255, 0.4);
      transform: translateY(-2px);
    }

    .divider {
      width: 1px;
      height: 32px;
      background: rgba(255, 255, 255, 0.2);
    }

    .instruction {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.7);
      font-style: italic;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="info-card">
    <h2 id="card-title"></h2>
    <p class="label">Inspiration:</p>
    <p class="inspiration" id="card-inspiration"></p>
    <p class="label">Role:</p>
    <p class="role">Designer</p>
    <div class="buttons">
      <button id="btn-continue">Continue</button>
      <button id="btn-return">Return to Start</button>
    </div>
  </div>
  <div id="controls-menu">
    <div class="control-group">
      <span class="control-label">Move:</span>
      <div class="keys">
        <span class="key" data-key="w">W</span>
        <span class="key" data-key="a">A</span>
        <span class="key" data-key="s">S</span>
        <span class="key" data-key="d">D</span>
      </div>
    </div>
    <div class="divider"></div>
    <div class="control-group">
      <span class="control-label">Look:</span>
      <span class="key">MOUSE</span>
    </div>
    <div class="divider"></div>
    <span class="instruction">Click to start exploring</span>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); // Will be replaced by stadium HDRI

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    // Will be positioned after store loads
    let initialCameraSet = false;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Load Stadium HDRI
    const exrLoader = new EXRLoader();
    exrLoader.load('Stadium_4k.exr', (texture) => {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      scene.background = texture;
      scene.environment = texture;
      console.log('Stadium HDRI loaded');
    }, undefined, (error) => {
      console.error('Error loading Stadium HDRI:', error);
      console.log('Using white background instead');
    });

    // Lighting - Much brighter
    const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Add additional lights for brightness
    const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
    fillLight.position.set(-10, 10, -5);
    scene.add(fillLight);

    const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
    backLight.position.set(0, 5, -10);
    scene.add(backLight);

    // First-person controls (click to activate)
    const controls = new PointerLockControls(camera, document.body);

    // Click to start walking
    document.body.addEventListener('click', () => {
      controls.lock();
    });

    controls.addEventListener('lock', () => {
      console.log('Controls locked - use WASD to move, mouse to look around');
      // Keep menu visible so key highlighting is shown
      const menu = document.getElementById('controls-menu');
      const instruction = menu.querySelector('.instruction');
      if (instruction) {
        instruction.style.display = 'none';
      }
    });

    controls.addEventListener('unlock', () => {
      console.log('Controls unlocked - click to re-enter');
      const menu = document.getElementById('controls-menu');
      const instruction = menu.querySelector('.instruction');
      if (instruction) {
        instruction.style.display = 'block';
      }
    });

    scene.add(controls.getObject());

    // Movement
    const moveSpeed = 0.08; // Slower movement
    const moveState = { forward: false, backward: false, left: false, right: false };

    // Key highlighting functions
    function highlightKey(key) {
      const keyElement = document.querySelector(`.key[data-key="${key}"]`);
      if (keyElement) {
        keyElement.classList.add('active');
      }
    }

    function unhighlightKey(key) {
      const keyElement = document.querySelector(`.key[data-key="${key}"]`);
      if (keyElement) {
        keyElement.classList.remove('active');
      }
    }

    // Path creation for clothing movement
    const pathWaypoints = [
      {
        "x": 4.160000000000002,
        "y": 0.5,
        "z": 20.74000000000004
      },
      {
        "x": 5.600000000000003,
        "y": 0.5,
        "z": 11.460000000000138
      },
      {
        "x": 5.600000000000003,
        "y": 0.5,
        "z": -6.939999999999876
      },
      {
        "x": -6.882263669116063,
        "y": 0.5,
        "z": -7.154228136959438
      },
      {
        "x": -6.7633441334354165,
        "y": 0.5,
        "z": 11.405390882407119
      },
      {
        "x": -6.146900413094533,
        "y": 0.5,
        "z": 21.028412850931645
      }
    ];
    const waypointMarkers = [];
    let isRecordingPath = false;

    // Create visual path line
    function createPathLine() {
      const points = pathWaypoints.map(wp => new THREE.Vector3(wp.x, wp.y, wp.z));
      // Close the loop by adding the first point at the end
      points.push(new THREE.Vector3(pathWaypoints[0].x, pathWaypoints[0].y, pathWaypoints[0].z));

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0xff00ff,  // Magenta line
        linewidth: 3,
        opacity: 0.8,
        transparent: true
      });
      const line = new THREE.Line(geometry, material);
      scene.add(line);

      // Add sphere markers at each waypoint
      pathWaypoints.forEach((wp, index) => {
        const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({
          color: 0xff00ff,
          opacity: 0.8,
          transparent: true
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(wp.x, wp.y, wp.z);
        scene.add(sphere);
      });

      console.log('Path line visualized in magenta');
    }

    document.addEventListener('keydown', (e) => {
      switch(e.code) {
        case 'KeyW': case 'ArrowUp':
          moveState.forward = true;
          highlightKey('w');
          break;
        case 'KeyS': case 'ArrowDown':
          moveState.backward = true;
          highlightKey('s');
          break;
        case 'KeyA': case 'ArrowLeft':
          moveState.left = true;
          highlightKey('a');
          break;
        case 'KeyD': case 'ArrowRight':
          moveState.right = true;
          highlightKey('d');
          break;
        case 'KeyP': // Press P to add current position as waypoint
          if (controls.isLocked) {
            const waypoint = {
              x: camera.position.x,
              y: 0.5, // Keep at ground level
              z: camera.position.z
            };
            pathWaypoints.push(waypoint);

            // Add visual marker for waypoint
            const markerGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const markerMaterial = new THREE.MeshStandardMaterial({
              color: 0xff0000,
              emissive: 0xff0000,
              emissiveIntensity: 0.5
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(waypoint.x, waypoint.y, waypoint.z);
            scene.add(marker);
            waypointMarkers.push(marker);

            console.log(`Waypoint ${pathWaypoints.length} added:`, waypoint);
            console.log('Total waypoints:', pathWaypoints.length);
          }
          break;
        case 'KeyC': // Press C to clear all waypoints
          pathWaypoints.length = 0;
          // Remove visual markers
          waypointMarkers.forEach(marker => scene.remove(marker));
          waypointMarkers.length = 0;
          console.log('All waypoints cleared');
          break;
        case 'KeyL': // Press L to log the complete path
          console.log('Complete path waypoints:', JSON.stringify(pathWaypoints, null, 2));
          break;
        case 'KeyM': // Press M to mark/log current camera position
          console.log('ðŸ“ Current Position:', {
            x: camera.position.x.toFixed(2),
            y: camera.position.y.toFixed(2),
            z: camera.position.z.toFixed(2)
          });
          console.log(`Position (x: ${camera.position.x.toFixed(2)}, y: ${camera.position.y.toFixed(2)}, z: ${camera.position.z.toFixed(2)})`);
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch(e.code) {
        case 'KeyW': case 'ArrowUp':
          moveState.forward = false;
          unhighlightKey('w');
          break;
        case 'KeyS': case 'ArrowDown':
          moveState.backward = false;
          unhighlightKey('s');
          break;
        case 'KeyA': case 'ArrowLeft':
          moveState.left = false;
          unhighlightKey('a');
          break;
        case 'KeyD': case 'ArrowRight':
          moveState.right = false;
          unhighlightKey('d');
          break;
      }
    });

    const loader = new GLTFLoader();
    const clothingModels = [];

    // Clothing info for presentation cards
    const clothingInfo = {
      'Love (Final).gltf': {
        title: 'Love',
        inspiration: 'Inspired by the famous Love Statue found on the University of Pennsylvania campus'
      },
      'Pink Floyd (Final).gltf': {
        title: 'Pink Floyd',
        inspiration: 'Inspired by the iconic triangular prism logo and its resemblance to our fraternity emblem'
      },
      'Purple Crown (Final).gltf': {
        title: 'Purple Crown',
        inspiration: 'Inspired by sports team logos featuring royalty colors and regal symbolism'
      },
      'Skyline Final.gltf': {
        title: 'Skyline',
        inspiration: 'Inspired by the iconic Philadelphia skyline and city architecture'
      },
      'Yellow Brick (final).gltf': {
        title: 'Yellow Brick Road',
        inspiration: 'Inspired by The Wizard of Oz, paying homage to the fraternity name OZ'
      }
    };

    // Presentation mode variables
    let presentationMode = true;
    let presentationPhase = 'moving'; // 'moving', 'rotating', 'displaying'
    let rotationStartAngle = 0;
    let rotationTimer = 0;
    let displayTimer = 0;
    let pathPauseTime = 0;
    let presentingItemIndex = -1;
    const ROTATION_DURATION = 200;
    const DISPLAY_DURATION = 360; // 6 seconds at 60fps for comfortable reading time
    const itemsPresentedThisCycle = new Set();
    const WALK_INTO_DISTANCE = 1.5; // Very close - basically touching

    // Track if user has started exploring
    let userHasStartedExploring = false;
    let startingCameraPosition = null;
    let startingCameraRotation = null;

    // Load the clothing store
    loader.load('clothing_store.glb', (gltf) => {
      const store = gltf.scene;

      // Center and scale the store
      const box = new THREE.Box3().setFromObject(store);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      // Scale store to 3x larger
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 30 / maxDim; // 3x larger (was 10, now 30)
      store.scale.setScalar(scale);

      store.position.x = -center.x * scale;
      store.position.y = -center.y * scale;
      store.position.z = -center.z * scale;

      store.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      scene.add(store);

      // Calculate store dimensions after scaling
      const scaledBox = new THREE.Box3().setFromObject(store);
      const scaledSize = scaledBox.getSize(new THREE.Vector3());
      const targetHeight = scaledSize.y * 0.05; // 5% of store height

      console.log('Store loaded');
      console.log('Store height:', scaledSize.y.toFixed(2));
      console.log('Clothing center height (5%):', targetHeight.toFixed(2));
      console.log('Store size - X:', scaledSize.x.toFixed(2), 'Z:', scaledSize.z.toFixed(2));

      // Position camera in front of the brick border (outside the store)
      const frontEdge = scaledBox.max.z + (scaledSize.z * 0.35); // 35% beyond front edge (moved back)
      camera.position.set(0, 0.05, frontEdge - 2); // Lower (0.05) and forward (frontEdge - 2)
      camera.lookAt(0, 0.05, 0);
      initialCameraSet = true;

      // Store starting position for "return to start"
      startingCameraPosition = camera.position.clone();
      startingCameraRotation = camera.rotation.clone();

      // Store camera z position for clothing path
      window.cameraStartZ = frontEdge;
      console.log('Camera positioned at brick border, z:', frontEdge.toFixed(2));

      // Create brick ground beneath the store
      const groundSize = createBrickGround(scaledSize, scaledBox);

      // Add columns at the four corners of the brick plane
      addCornerColumns(groundSize, scaledBox);

      // After store loads, load clothing models at 5% height
      loadClothingModels(targetHeight, scaledSize);

      // Create visual path line
      // createPathLine(); // Disabled - no need to show path visualization
    });

    function createBrickGround(storeSize, storeBox) {
      // Calculate ground size
      const groundSize = Math.max(storeSize.x, storeSize.z) * 2.5; // 150% larger than store

      // Load brick texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('mixed_brick_wall_diff_4k.jpg', (brickTexture) => {
        brickTexture.wrapS = THREE.RepeatWrapping;
        brickTexture.wrapT = THREE.RepeatWrapping;
        brickTexture.repeat.set(8, 8); // Tile the texture

        // Create large ground plane
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshStandardMaterial({
          map: brickTexture,
          roughness: 0.8,
          metalness: 0.1,
          color: new THREE.Color(0.4, 0.4, 0.4) // Darken to 40% brightness
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal

        // Position beneath the bottom of the store model
        ground.position.y = storeBox.min.y - 0.1; // Slightly below the store's lowest point

        ground.receiveShadow = true;
        scene.add(ground);
        console.log('Brick ground layered beneath store at y:', ground.position.y.toFixed(2));
      });

      return groundSize;
    }

    function addCornerColumns(groundSize, storeBox) {
      // Load Greek column model
      const columnLoader = new GLTFLoader();
      columnLoader.load('greek_column.glb', (gltf) => {
        const columnTemplate = gltf.scene;

        // Scale column appropriately
        const columnBox = new THREE.Box3().setFromObject(columnTemplate);
        const columnSize = columnBox.getSize(new THREE.Vector3());
        const columnScale = 35 / columnSize.y; // Make columns 35 units tall (5x larger than 7)
        columnTemplate.scale.setScalar(columnScale);

        // Position columns at the four corners of the brick plane
        const halfSize = groundSize / 2;
        const groundY = storeBox.min.y - 0.1; // Same as brick ground

        const cornerPositions = [
          { x: halfSize, z: halfSize },     // Front-right corner
          { x: -halfSize, z: halfSize },    // Front-left corner
          { x: halfSize, z: -halfSize },    // Back-right corner
          { x: -halfSize, z: -halfSize }    // Back-left corner
        ];

        cornerPositions.forEach((pos) => {
          const column = columnTemplate.clone();
          column.position.set(pos.x, groundY, pos.z);
          column.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          scene.add(column);
        });

        console.log('Greek columns added at four corners');
      });
    }

    function loadClothingModels(targetHeight, storeSize) {
      // Position clothing in open areas within the store on the ground floor
      // Use small spread to keep them in open floor spaces
      const safeZoneX = storeSize.x * 0.25; // Keep within 50% of store width
      const safeZoneZ = storeSize.z * 0.25; // Keep within 50% of store depth

      // Calculate 1/30 of store width for nudge amount
      const nudgeRight = storeSize.x / 30;

      const clothingConfigs = [
        {
          file: 'Love (Final).gltf',
          position: { x: safeZoneX * 0.55 + nudgeRight, y: targetHeight, z: safeZoneZ * 0.7 }, // Nudged right
          rotation: Math.PI * 0.3
        },
        {
          file: 'Pink Floyd (Final).gltf',
          position: { x: -safeZoneX * 1.125 + nudgeRight, y: targetHeight, z: safeZoneZ * 0.9 }, // Nudged right
          rotation: Math.PI * 0.7,
          scaleFactor: 1.05
        },
        {
          file: 'Purple Crown (Final).gltf',
          position: { x: safeZoneX * 0.6, y: targetHeight, z: -safeZoneZ * 0.8 },
          rotation: Math.PI * 1.2
        },
        {
          file: 'Skyline Final.gltf',
          position: { x: -safeZoneX * 0.7, y: targetHeight, z: -safeZoneZ * 0.6 },
          rotation: Math.PI * 1.8
        },
        {
          file: 'Yellow Brick (final).gltf',
          position: { x: -safeZoneX * 0.325 + nudgeRight, y: targetHeight, z: 0 }, // Nudged right
          rotation: Math.PI * 0.5
        }
      ];
      clothingConfigs.forEach((config, index) => {
        loader.load(config.file, (gltf) => {
          const model = gltf.scene;

          // Center and scale model
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          // Scale to consistent height
          let scale = 1.5 / size.y;
          if (config.scaleFactor) scale *= config.scaleFactor;

          model.scale.setScalar(scale);

          // Center the model
          model.position.x = -center.x * scale;
          model.position.y = -center.y * scale;
          model.position.z = -center.z * scale;

          // Create container for positioning
          const container = new THREE.Group();
          container.add(model);

          // Set floating position
          container.position.set(
            config.position.x,
            config.position.y,
            config.position.z
          );
          container.rotation.y = config.rotation;

          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          scene.add(container);

          // Calculate path radius from initial position
          const pathRadius = Math.sqrt(config.position.x * config.position.x + config.position.z * config.position.z);
          const startAngle = Math.atan2(config.position.z, config.position.x);

          clothingModels.push({
            container,
            baseY: config.position.y,
            phase: index * 0.5,
            pathRadius: pathRadius,
            startAngle: startAngle,
            filename: config.file
          });

          console.log(`Loaded ${config.file} - pathRadius: ${pathRadius.toFixed(2)}, startAngle: ${startAngle.toFixed(2)}`);
        });
      });
    }

    // Animation
    let time = 0;

    // Helper function to show/hide info card
    function showInfoCard(item, itemIndex, showButtons = false) {
      const info = clothingInfo[item.filename];
      if (info) {
        document.getElementById('card-title').textContent = info.title;
        document.getElementById('card-inspiration').textContent = info.inspiration;

        const card = document.getElementById('info-card');
        // Alternate sides based on item index
        const side = itemIndex % 2 === 0 ? 'left' : 'right';
        card.classList.remove('left', 'right');
        card.classList.add(side);
        card.classList.add('visible');

        // Show buttons only in exploration mode
        if (showButtons) {
          card.classList.add('with-buttons');
          controls.unlock(); // Let user click buttons
        } else {
          card.classList.remove('with-buttons');
        }
      }
    }

    function hideInfoCard() {
      const card = document.getElementById('info-card');
      card.classList.remove('visible', 'with-buttons');
      presentationPhase = 'moving';
      presentingItemIndex = -1;
    }

    // Button handlers
    document.getElementById('btn-continue').addEventListener('click', (e) => {
      e.stopPropagation();
      hideInfoCard();
    });

    document.getElementById('btn-return').addEventListener('click', (e) => {
      e.stopPropagation();
      if (startingCameraPosition && startingCameraRotation) {
        camera.position.copy(startingCameraPosition);
        camera.rotation.copy(startingCameraRotation);
      }
      hideInfoCard();
    });

    function animate() {
      requestAnimationFrame(animate);

      // Only advance time when in moving phase
      if (presentationPhase === 'moving') {
        time += 0.01;
      }

      // Handle Arrow Key movement
      if (controls.isLocked) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0; // Keep movement horizontal
        direction.normalize();

        const right = new THREE.Vector3();
        right.crossVectors(camera.up, direction).normalize();

        if (moveState.forward) {
          camera.position.addScaledVector(direction, moveSpeed);
        }
        if (moveState.backward) {
          camera.position.addScaledVector(direction, -moveSpeed);
        }
        if (moveState.left) {
          camera.position.addScaledVector(right, moveSpeed); // Reversed for correct left movement
        }
        if (moveState.right) {
          camera.position.addScaledVector(right, -moveSpeed); // Reversed for correct right movement
        }
      }

      // Check if user has started exploring (moved away from start)
      if (startingCameraPosition && !userHasStartedExploring) {
        const distFromStart = camera.position.distanceTo(startingCameraPosition);
        if (distFromStart > 3) {
          userHasStartedExploring = true;
          console.log('User started exploring');
        }
      }

      // Handle presentation mode state machine
      if (presentationMode && presentationPhase === 'rotating') {
        rotationTimer++;

        if (presentingItemIndex >= 0 && presentingItemIndex < clothingModels.length) {
          const item = clothingModels[presentingItemIndex];
          const rotationProgress = rotationTimer / ROTATION_DURATION;
          item.container.rotation.y = rotationStartAngle + (rotationProgress * Math.PI * 2);

          if (rotationTimer >= ROTATION_DURATION) {
            presentationPhase = 'displaying';
            displayTimer = 0;
            showInfoCard(item, presentingItemIndex, userHasStartedExploring);
          }
        }
      } else if (presentationMode && presentationPhase === 'displaying') {
        // Auto-dismiss only in initial mode, not when exploring
        if (!userHasStartedExploring) {
          displayTimer++;
          if (displayTimer >= DISPLAY_DURATION) {
            hideInfoCard();
            presentationPhase = 'moving';
            presentingItemIndex = -1;
          }
        }
        // When exploring, user must click a button to dismiss
      }

      // Animate clothing items
      clothingModels.forEach((item, index) => {
        const floatAmount = Math.sin(time + item.phase) * 0.1;
        item.container.position.y = item.baseY + floatAmount;

        // If path waypoints exist, follow the path
        if (pathWaypoints.length >= 2) {
          const speed = 0.05; // Speed along path
          const spacing = 0.2; // Spacing between items (0-1 range)

          // Calculate position along path (0 to 1)
          const progress = ((time * speed) + (index * spacing)) % 1;

          // Calculate which segment and position within that segment
          const totalSegments = pathWaypoints.length;
          const segmentProgress = progress * totalSegments;
          const currentSegment = Math.floor(segmentProgress);
          const segmentT = segmentProgress - currentSegment;

          // Get start and end waypoints (loop back to start)
          const start = pathWaypoints[currentSegment % totalSegments];
          const end = pathWaypoints[(currentSegment + 1) % totalSegments];

          // Check if this is the presentation segment and near stopping point
          const isFrontSegment = (currentSegment === 5);
          const isNearStoppingPoint = (segmentT >= 0.55 && segmentT <= 0.65);

          // Use linear interpolation for smooth, constant-speed movement
          let interpolationT = segmentT;

          // Interpolate position
          item.container.position.x = start.x + (end.x - start.x) * interpolationT;
          item.container.position.z = start.z + (end.z - start.z) * interpolationT;

          // Calculate distance to player
          const distanceToPlayer = Math.sqrt(
            Math.pow(item.container.position.x - camera.position.x, 2) +
            Math.pow(item.container.position.z - camera.position.z, 2)
          );

          if (!userHasStartedExploring) {
            // ORIGINAL MODE: Auto-presentation when items reach front position
            const isFrontSegment = (currentSegment === 5);
            const isAtStoppingPoint = (segmentT >= 0.6 && segmentT < 0.61);

            if (presentationMode &&
                presentationPhase === 'moving' &&
                isFrontSegment &&
                isAtStoppingPoint &&
                !itemsPresentedThisCycle.has(index)) {

              // Trigger presentation
              presentationPhase = 'rotating';
              presentingItemIndex = index;
              rotationTimer = 0;
              itemsPresentedThisCycle.add(index);

              // Store the current rotation angle
              const dx = end.x - start.x;
              const dz = end.z - start.z;
              const baseRotation = Math.atan2(dx, dz);
              const additionalRotation = progress * Math.PI * 2;
              rotationStartAngle = baseRotation + additionalRotation;

              console.log(`ðŸŽ¯ Auto-presentation for ${item.filename}`);
            }

            // Clear cycle tracking when all items have been presented
            if (itemsPresentedThisCycle.size === clothingModels.length &&
                currentSegment === 0 &&
                segmentT < 0.1) {
              itemsPresentedThisCycle.clear();
              console.log('New cycle started');
            }
          } else {
            // EXPLORATION MODE: Walk into item to trigger (no rotation, just stop and show)
            if (presentationPhase === 'moving' &&
                distanceToPlayer < WALK_INTO_DISTANCE &&
                controls.isLocked) {

              // Skip rotation, go straight to displaying
              presentationPhase = 'displaying';
              presentingItemIndex = index;
              showInfoCard(item, index, true); // true = show buttons

              console.log(`ðŸŽ¯ Walk-into presentation for ${item.filename}`);
            }
          }

          // Only update rotation if not in presentation mode
          if (presentationPhase === 'moving' || presentingItemIndex !== index) {
            // Face direction of movement
            const dx = end.x - start.x;
            const dz = end.z - start.z;
            const baseRotation = Math.atan2(dx, dz);

            // Add 180-degree rotation along the path (full rotation per complete path loop)
            const additionalRotation = progress * Math.PI * 2; // Full 360-degree rotation per loop
            item.container.rotation.y = baseRotation + additionalRotation;
          }
        } else {
          // No path - just rotate in place
          item.container.rotation.y += 0.005;
        }
      });

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
